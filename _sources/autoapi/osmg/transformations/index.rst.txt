:py:mod:`osmg.transformations`
==============================

.. py:module:: osmg.transformations

.. autoapi-nested-parse::

   Performs coordinate transformations



Module Contents
---------------


Functions
~~~~~~~~~

.. autoapisummary::

   osmg.transformations.rotation_matrix_2d
   osmg.transformations.rotation_matrix_3d
   osmg.transformations.transformation_matrix
   osmg.transformations.local_axes_from_points_and_angle
   osmg.transformations.offset_transformation



Attributes
~~~~~~~~~~

.. autoapisummary::

   osmg.transformations.nparr


.. py:data:: nparr
   

   

.. py:function:: rotation_matrix_2d(ang: float) -> nparr

   Return a 2D transformation matrix.

   :param ang: Angle in radians to rotate the matrix by.
   :type ang: float

   :returns: A 2x2 transformation matrix.
   :rtype: nparr

   .. rubric:: Example

   >>> rotation_matrix_2d(np.pi / 2)
   array([[ 6.123234e-17, -1.000000e+00],
          [ 1.000000e+00,  6.123234e-17]])

   :raises TypeError: If `ang` is not a float.


.. py:function:: rotation_matrix_3d(axis: nparr, theta: float) -> nparr

   Return the rotation matrix associated with counterclockwise
   rotation about the given axis by theta radians.

   :param axis: 3D vector representing the axis of rotation.
   :type axis: nparr
   :param theta: Angle of rotation in radians.
   :type theta: float

   :returns: 3x3 transformation matrix representing the rotation.
   :rtype: nparr

   Example:
   >>> # this is how to run that function:
   >>> res = rotation_matrix_3d(np.array([1, 0, 0]), np.pi/2)
   >>> # this is the expected result:
   >>> expected_res = np.array(
   ...     [[ 1.00000000e+00,  0.00000000e+00, -0.00000000e+00],
   ...      [-0.00000000e+00,  2.22044605e-16, -1.00000000e+00],
   ...      [ 0.00000000e+00,  1.00000000e+00,  2.22044605e-16]])
   >>> assert np.allclose(res, expected_res)


.. py:function:: transformation_matrix(vec_x: nparr, vec_y: nparr, vec_z: nparr) -> nparr

   Returns a transformation matrix that transforms points from
   the coordinate system in which the x, y and z axes are expressed,
   to the local coordinate system defined by them.
   :param vec_x: Local x axis expressed in the global system
   :type vec_x: nparr
   :param vec_y: (similar)
   :type vec_y: nparr
   :param vec_z: (similar)
   :type vec_z: nparr

   :returns: global to local transformation matrix.
   :rtype: (nparr)

   Note: For orthogonal axes, transpose to obtain the inverse transform.

   .. rubric:: Example

   >>> # this is how to run that function:
   >>> res = transformation_matrix(
   ...     np.array([1., 0., 0.]),
   ...     np.array([0., 1., 0.]),
   ...     np.array([0., 0., 1.]))
   >>> expected_result = np.array((
   ...     [[1., 0., 0.],
   ...      [0., 1., 0.],
   ...      [0., 0., 1.]]))
   >>> assert np.allclose(res, expected_result)
   >>> res = transformation_matrix(
   ...     np.array([1., 0., 0.]),
   ...     np.array([0., 0., 1.]),
   ...     np.array([0., 1., 0.]))
   >>> expected_result = np.array((
   ...     [[1., 0., 0.],
   ...      [0., 0., 1.],
   ...      [0., 1., 0.]]))
   >>> assert np.allclose(res, expected_result)


.. py:function:: local_axes_from_points_and_angle(point_i: nparr, point_j: nparr, ang: float) -> tuple[nparr, nparr, nparr]

   Given a start point, and end point, and an angle,
   obtain the local coordinate system of a linear element.
   :param point_i: Start point
   :type point_i: nparr
   :param point_j: End point
   :type point_j: nparr
   :param ang: Parameter that controls the rotation of the
               section around the x-axis. Counterclockwise rotation is
               posotive. 0.00 corresponds to:
                 vertical elements whose local z axis coincides with
                                   the local x axis
                 horizontal elements whose local z axis is horizontal.
   :type ang: float

   :returns:

             Local coordinate system
                 vectors. The first element is the local x axis, the second
                 element is the local y axis, and the third element is the
                 local z axis.
   :rtype: tuple[nparr, nparr, nparr]

   :raises ValueError: If the start point and end point define a vertical element
       that is defined upside down (i.e., with the start point at a lower
       height than the end point).

   .. note::

      For vertical elements, the local x axis will be the vector connecting
      the start and end points, and the local z axis will be perpendicular
      to the local x axis and lying on the plane defined by the global xy
      plane and the local x axis. For horizontal elements, the local z axis
      will be parallel to the global z axis.

   .. rubric:: Example

   >>> point_i = np.array([0, 0, 0])
   >>> point_j = np.array([1, 0, 0])
   >>> ang = 0
   >>> local_axes_from_points_and_angle(point_i, point_j, ang)
   (array([1., 0., 0.]), array([0., 0., 1.]), array([ 0., -1.,  0.]))


.. py:function:: offset_transformation(offset: nparr, u_vec: nparr, r_vec: nparr) -> nparr

   Calculate the displacement at the end of a rigid offset by
   specifying the displacement and rotation of the other end.

   A rigid offset connects two nodes and transmits forces between
   them, but does not allow any relative displacement or rotation
   between the nodes.

   :param offset: Vector pointing from the node of the rigid offset where the
                  displacement is known to the node where we want to obtain
                  the displacement. The vector should be given in the global
                  coordinate system.
   :type offset: nparr
   :param u_vec: Displacement of the node where the displacement is known,
                 given in the global coordinate system.
   :type u_vec: nparr
   :param r_vec: Rotation of the node where the displacement is known, given
                 as a vector of the form [rx, ry, rz] representing the
                 rotation around the x, y, and z axes, respectively.
   :type r_vec: nparr

   :returns: Displacement at the other end of the rigid offset,
             given in the global coordinate system.
   :rtype: nparr

   .. rubric:: Example

   Calculate the displacement of the end of a rigid offset with a
   length of 1 meter, given a displacement of [4, 5, 6] and a
   rotation of [7, 8, 9] at the other end:

   >>> offset_transformation(np.array([1., 0., 0.]),
   ...     np.array([0.01, -0.02, 0.005]),
   ...     np.array([0.0002, -0.0003, 0.0001]))
   array([ 0.01  , -0.0199,  0.0053])


