:py:mod:`osmg.collections`
==========================

.. py:module:: osmg.collections

.. autoapi-nested-parse::

   Model Generator for OpenSees ~ collections
   Collections are designated containers of objects of a particular type.



Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   osmg.collections.Collection
   osmg.collections.CollectionActive
   osmg.collections.NodeCollection
   osmg.collections.CollectionWithConnectivity




Attributes
~~~~~~~~~~

.. autoapisummary::

   osmg.collections.nparr
   osmg.collections.TK
   osmg.collections.TV


.. py:data:: nparr
   

   

.. py:data:: TK
   

   

.. py:data:: TV
   

   

.. py:class:: Collection

   Bases: :py:obj:`dict`\ [\ :py:obj:`TK`\ , :py:obj:`TV`\ ]

   Collection of objects.

   .. attribute:: parent

      

      :type: Any

   .. rubric:: Examples

   # collections require parent objects to which they belong
   >>> parent = 52
   >>> my_collection = Collection(parent=parent)
   >>> my_collection.parent
   52
   >>> # now `my_collection` knows that it belongs to the object `52`.
   >>>
   >>>
   >>>
   >>> # Collection.add method
   >>>
   >>> from osmg.ops.node import Node
   >>> my_collection = Collection(parent=None)
   >>> len(my_collection)
   0
   >>> # something to add:
   >>> new_node = Node(uid=0, coords=[0.00, 0.00])
   >>> # add the node to the collection
   >>> my_collection.add(new_node)
   >>> # it has been added:
   >>> len(my_collection)
   1
   >>> # and it can be accessed by its uid:
   >>> id(new_node) == id(my_collection[0])
   True
   >>> # adding something without a uid fails:
   >>> my_collection.add(42)
   Traceback (most recent call last):
       ...
   KeyError: 'Object does not have a uid attribute'
   >>> # adding an object with the same uid fails:
   >>> my_collection.add(new_node)
   Traceback (most recent call last):
       ...
   KeyError: 'uid 0 already exists'
   >>>
   >>>
   >>>
   >>> # Collections.retrieve_by_attr method:
   >>>
   >>> from osmg.ops.section import Section
   >>> sec_collection = Collection(parent=None)
   >>> sec_collection.add(Section(name='sec_1', uid=0))
   >>> sec_collection.add(Section(name='sec_2', uid=1))
   >>> sec_collection.retrieve_by_attr('name', 'sec_1')
   Section(name='sec_1', uid=0)
   >>> # we 'll use this later:
   >>>
   >>>
   >>>
   >>> # Collections.__srepr__ method:
   >>>
   >>> sec_collection.__srepr__()
   '[Collection of 2 items]'

   .. py:attribute:: parent
      :annotation: :Any

      

   .. py:method:: add(obj: Any) -> None

      Add an object to the collection. The object needs to have
      a unique id attribute, `uid`.



   .. py:method:: retrieve_by_attr(attr: Any, val: Any) -> Any

      Retrieve an object from the collection based on an attribute
      value.



   .. py:method:: __srepr__()

      Short version of repr



   .. py:method:: __repr__()

      Return repr(self).



.. py:class:: CollectionActive

   Bases: :py:obj:`Collection`\ [\ :py:obj:`TK`\ , :py:obj:`TV`\ ]

   Collection with support for currently active objects.

   .. rubric:: Examples

   >>> from osmg.level import Level
   >>> my_collection = CollectionActive(parent=None)
   >>> my_collection.add(Level(
   ...     parent_model=None,
   ...     uid=0,
   ...     elevation=0.00))
   >>> my_collection.add(Level(
   ...     parent_model=None,
   ...     uid=1,
   ...     elevation=1.00))
   >>>
   >>>
   >>>
   >>> # CollectionActive.set_active method:
   >>>
   >>> # set them both as active
   >>> my_collection.set_active([0, 1])
   >>> my_collection.active
   [0, 1]
   >>> # if uid is not present, it fails
   >>> my_collection.set_active([2])
   Traceback (most recent call last):
       ....
   KeyError: 'uid 2 not present in collection.'

   .. py:attribute:: active
      :annotation: :list[TK]

      

   .. py:method:: set_active(uids: list[TK]) -> None

      Sets the active objects.
      :param uids: uids of the objects to set as active
      :type uids: list[int]


   .. py:method:: set_active_all()

      Sets the active objects.
      :param uids: uids of the objects to set as active
      :type uids: list[int]



.. py:class:: NodeCollection

   Bases: :py:obj:`Collection`\ [\ :py:obj:`int`\ , :py:obj:`osmg.ops.node.Node`\ ]

   Node collection.
   .. attribute:: parent

      

      :type: Any

   .. rubric:: Examples

   >>> from osmg.ops.node import Node
   >>> from osmg.level import Level
   >>> level = Level(parent_model=None, uid=0, elevation=0.00)
   >>>
   >>> my_collection = NodeCollection(parent=level)
   >>>
   >>> n_1 = Node(uid=0, coords=[0.00, 0.00, 0.00])
   >>> n_2 = Node(uid=1, coords=[1.00, 1.00, 0.00])
   >>> my_collection.add(n_1)
   >>> my_collection.add(n_2)
   >>>
   >>>
   >>>
   >>> # NodeCollection.search_xy method:
   >>>
   >>> retrieved_node = my_collection.search_xy(1.00, 1.00)
   >>> id(retrieved_node) == id(n_2)  # should be the same object
   True

   .. py:attribute:: named_contents
      :annotation: :dict[str, osmg.ops.node.Node]

      

   .. py:method:: search_xy(x_coord, y_coord)

      Returns the node that occupies a given point if it exists



.. py:class:: CollectionWithConnectivity

   Bases: :py:obj:`Collection`\ [\ :py:obj:`TK`\ , :py:obj:`TV`\ ]

   Collection of elements for which it is important to consider their
   connectivity.
   .. attribute:: parent

      

      :type: Any

   .. py:attribute:: named_contents
      :annotation: :dict[str, osmg.ops.element.ElasticBeamColumn]

      

   .. py:method:: add(obj)

      Adds an element to the collection.
      The method also checks to see if an object having the same
      connectivity exists in the collection, and raises an error if
      it does.



